**IMPORTANT: Return ONLY the two code files. No explanations, no commentary, just the code.**

I am customizing an IOTA dApp built with Next.js, React, and TypeScript. Update the contract integration hook and UI component.

## Contract Details

- **Network:** `devnet`
- **Package ID:** `0x703c97fb88edc981081307351be009b7815b1f5ae2e31421e9ef9d84bf2b0856`
- **Module Name:** `contract`
- **Available Methods:**

  * `get_trust_score` (constant: `GET_TRUST_SCORE`)
  * `get_owner` (constant: `GET_OWNER`)
  * `mint_to_sender` (constant: `MINT_TO_SENDER`)
  * `add_event` (constant: `ADD_EVENT`)
  * `report_lost` (constant: `REPORT_LOST`)
  * `transfer_twin` (constant: `TRANSFER_TWIN`)

---

# **Move Contract: `contract/digital_twin_dapp/sources/digital_twin_dapp.move`**

```move
module digital_twin_dapp::contract {
use std::vector;
use iota::object;
use iota::tx_context;
use iota::transfer;
const INITIAL_TRUST_SCORE: u64 = 50;
const MAX_TRUST_SCORE: u64 = 100;
const MIN_TRUST_SCORE: u64 = 0;
const EVENT_CREATED: u8 = 0;
const EVENT_MAINTENANCE: u8 = 1;
const EVENT_DAMAGE: u8 = 2;
const EVENT_INSPECTION: u8 = 3;
const EVENT_LOST: u8 = 4;
const EVENT_VERIFICATION: u8 = 5;
public struct LifecycleEvent has copy, drop, store {
event_type: u8,
description: vector<u8>,
}
public struct DigitalTwin has key, store {
id: object::UID,
owner: address,
metadata: vector<u8>,
trust_score: u64,
logs: vector<LifecycleEvent>,
}
public fun get_trust_score(twin: &DigitalTwin): u64 {
twin.trust_score
}
public fun get_owner(twin: &DigitalTwin): address {
twin.owner
}
#[allow(lint(self_transfer))]
public fun mint_to_sender(
metadata: vector<u8>,
ctx: &mut tx_context::TxContext
) {
let sender = tx_context::sender(ctx);
let mut logs = vector::empty<LifecycleEvent>();
vector::push_back(&mut logs, LifecycleEvent {
event_type: EVENT_CREATED,
description: b"Created",
});
let twin = DigitalTwin {
id: object::new(ctx),
owner: sender,
metadata,
trust_score: INITIAL_TRUST_SCORE,
logs,
};
transfer::public_transfer(twin, sender);
}
#[allow(lint(self_transfer))]
public fun add_event(
twin: &mut DigitalTwin,
event_type: u8,
desc: vector<u8>,
_ctx: &mut tx_context::TxContext
) {
vector::push_back(&mut twin.logs, LifecycleEvent {
event_type,
description: desc,
});
apply_trust_change(twin, event_type);
}
#[allow(lint(self_transfer))]
public fun report_lost(
twin: &mut DigitalTwin,
_ctx: &mut tx_context::TxContext
) {
vector::push_back(&mut twin.logs, LifecycleEvent {
event_type: EVENT_LOST,
description: b"Reported lost",
});
apply_trust_change(twin, EVENT_LOST);
}
#[allow(lint(self_transfer))]
public fun transfer_twin(
twin: DigitalTwin,
recipient: address,
_ctx: &mut tx_context::TxContext
) {
transfer::public_transfer(twin, recipient);
}
fun apply_trust_change(twin: &mut DigitalTwin, event_type: u8) {
let score_ref = &mut twin.trust_score;
if (event_type == EVENT_MAINTENANCE) {
increase(score_ref, 5);
} else if (event_type == EVENT_DAMAGE) {
decrease(score_ref, 3);
} else if (event_type == EVENT_INSPECTION) {
increase(score_ref, 2);
} else if (event_type == EVENT_LOST) {
decrease(score_ref, 50);
} else if (event_type == EVENT_VERIFICATION) {
increase(score_ref, 10);
};
}
fun increase(score: &mut u64, delta: u64) {
let new_score = *score + delta;
*score = if (new_score > MAX_TRUST_SCORE) {
MAX_TRUST_SCORE
} else {
new_score
};
}
fun decrease(score: &mut u64, delta: u64) {
*score = if (*score <= delta) {
MIN_TRUST_SCORE
} else {
*score - delta
};
}
}
```

---

# File 1: `hooks/useContract.ts`

```ts
"use client"

import { useState, useEffect, useCallback } from "react"
import {
  useCurrentAccount,
  useIotaClient,
  useSignAndExecuteTransaction,
  useIotaClientQuery,
} from "@iota/dapp-kit"
import { Transaction } from "@iota/iota-sdk/transactions"
import type { IotaObjectData } from "@iota/iota-sdk/client"

// ============================================================================
// CONTRACT CONFIGURATION
// ============================================================================

export const PACKAGE_ID =
  "0x703c97fb88edc981081307351be009b7815b1f5ae2e31421e9ef9d84bf2b0856"
export const CONTRACT_MODULE = "contract"
export const CONTRACT_METHODS = {
  GET_TRUST_SCORE: "get_trust_score",
  GET_OWNER: "get_owner",
  MINT_TO_SENDER: "mint_to_sender",
  ADD_EVENT: "add_event",
  REPORT_LOST: "report_lost",
  TRANSFER_TWIN: "transfer_twin",
} as const

// ============================================================================
// TYPES
// ============================================================================

export interface LifecycleEvent {
  event_type: number
  description: string
}

export interface ContractData {
  owner: string
  metadata: string
  trust_score: number
  logs: LifecycleEvent[]
}

export interface ContractState {
  isLoading: boolean
  isPending: boolean
  isConfirming: boolean
  isConfirmed: boolean
  hash: string | undefined
  error: Error | null
}

export interface ContractActions {
  mintToSender: (metadata: string) => Promise<void>
  addEvent: (eventType: number, description: string) => Promise<void>
  reportLost: () => Promise<void>
  transferTwin: (recipient: string) => Promise<void>
  clearObject: () => void
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Decode vector<u8> from various possible formats:
 * - number[] array
 * - "0x..." hex string
 * - { bytes: "0x..." } object
 * - plain string
 */
function decodeBytesField(value: unknown): string {
  console.log("üîç decodeBytesField input:", value, "| Type:", typeof value)
  
  if (value == null) {
    console.log("‚ùå Value is null/undefined")
    return ""
  }

  // Plain string (non-hex)
  if (typeof value === "string" && !value.startsWith("0x")) {
    console.log("‚úÖ Plain string:", value)
    return value
  }

  // Hex string "0x..."
  if (typeof value === "string" && value.startsWith("0x")) {
    const hex = value.slice(2)
    console.log("üîç Hex string, length:", hex.length)
    const bytes: number[] = []
    for (let i = 0; i < hex.length; i += 2) {
      const byte = parseInt(hex.slice(i, i + 2), 16)
      if (!Number.isNaN(byte)) bytes.push(byte)
    }
    const decoded = new TextDecoder().decode(new Uint8Array(bytes))
    console.log("‚úÖ Decoded from hex:", decoded)
    return decoded
  }

  // Array of numbers
  if (Array.isArray(value)) {
    console.log("üîç Array of bytes, length:", value.length, "| First 5:", value.slice(0, 5))
    const decoded = new TextDecoder().decode(new Uint8Array(value as number[]))
    console.log("‚úÖ Decoded from array:", decoded)
    return decoded
  }

  // Object with .bytes property
  if (typeof value === "object") {
    const obj = value as { bytes?: unknown }
    console.log("üîç Object detected, has .bytes?", !!obj.bytes)
    if (typeof obj.bytes === "string") {
      const hex = obj.bytes.startsWith("0x") ? obj.bytes.slice(2) : obj.bytes
      const bytes: number[] = []
      for (let i = 0; i < hex.length; i += 2) {
        const byte = parseInt(hex.slice(i, i + 2), 16)
        if (!Number.isNaN(byte)) bytes.push(byte)
      }
      const decoded = new TextDecoder().decode(new Uint8Array(bytes))
      console.log("‚úÖ Decoded from object.bytes:", decoded)
      return decoded
    }
  }

  console.log("‚ùå Could not decode, returning empty string")
  return ""
}

/**
 * Extract DigitalTwin fields from IOTA object data
 */
function extractDigitalTwinFields(data: IotaObjectData): ContractData | null {
  if (data.content?.dataType !== "moveObject") {
    console.log("‚ùå Data is not a moveObject:", data.content?.dataType)
    return null
  }

  const fields = data.content.fields as Record<string, unknown>
  if (!fields) {
    console.log("‚ùå No fields found in object data")
    return null
  }

  console.log("üì¶ Object fields:", JSON.stringify(fields, null, 2))

  // Extract owner
  if (!fields.owner) {
    console.log("‚ùå Owner field is missing")
    return null
  }
  const owner = String(fields.owner)

  // Extract trust_score
  let trust_score: number
  if (typeof fields.trust_score === "string") {
    trust_score = parseInt(fields.trust_score, 10)
    if (isNaN(trust_score)) {
      console.log("‚ùå Trust score is not a valid number:", fields.trust_score)
      return null
    }
  } else if (typeof fields.trust_score === "number") {
    trust_score = fields.trust_score
  } else {
    console.log("‚ùå Trust score invalid type:", typeof fields.trust_score)
    return null
  }

  // Extract metadata
  const metadata = decodeBytesField(fields.metadata)

  // Extract logs
  const rawLogs = fields.logs
  const logs: LifecycleEvent[] = Array.isArray(rawLogs)
    ? (rawLogs as Record<string, unknown>[]).map((log) => {
        const rawEventType = log.event_type
        let event_type = 0

        if (typeof rawEventType === "string") {
          const parsed = parseInt(rawEventType, 10)
          event_type = Number.isNaN(parsed) ? 0 : parsed
        } else if (typeof rawEventType === "number") {
          event_type = rawEventType
        }

        const description = decodeBytesField(log.description)

        return { event_type, description }
      })
    : []

  return {
    owner,
    metadata,
    trust_score,
    logs,
  }
}

// ============================================================================
// MAIN HOOK
// ============================================================================

export const useContract = () => {
  const currentAccount = useCurrentAccount()
  const address = currentAccount?.address
  const iotaClient = useIotaClient()
  const { mutate: signAndExecute, isPending } = useSignAndExecuteTransaction()

  const [objectId, setObjectId] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(false)
  const [hash, setHash] = useState<string | undefined>()
  const [transactionError, setTransactionError] = useState<Error | null>(null)

  // Load objectId from URL hash on mount
  useEffect(() => {
    if (typeof window !== "undefined") {
      const urlHash = window.location.hash.slice(1)
      if (urlHash) {
        setObjectId(urlHash)
      }
    }
  }, [])

  // Fetch object data from blockchain
  const {
    data,
    isPending: isFetching,
    error: queryError,
    refetch,
  } = useIotaClientQuery(
    "getObject",
    {
      id: objectId!,
      options: { showContent: true, showOwner: true },
    },
    {
      enabled: !!objectId,
      refetchInterval: false,
    }
  )

  // Extract and parse data
  const fields = data?.data ? extractDigitalTwinFields(data.data) : null
  const isOwner = fields?.owner.toLowerCase() === address?.toLowerCase()
  const objectExists = !!data?.data
  const hasValidData = !!fields

  // ============================================================================
  // ACTIONS
  // ============================================================================

  /**
   * Mint a new Digital Twin NFT
   */
  const mintToSender = useCallback(
    async (metadata: string) => {
      if (!metadata.trim()) {
        setTransactionError(new Error("Metadata cannot be empty"))
        return
      }

      try {
        setIsLoading(true)
        setTransactionError(null)
        setHash(undefined)

        const tx = new Transaction()
        const metadataBytes = new TextEncoder().encode(metadata)

        tx.moveCall({
          arguments: [tx.pure.vector("u8", Array.from(metadataBytes))],
          target: `${PACKAGE_ID}::${CONTRACT_MODULE}::${CONTRACT_METHODS.MINT_TO_SENDER}`,
        })

        signAndExecute(
          { transaction: tx.serialize() },
          {
            onSuccess: async ({ digest }) => {
              setHash(digest)
              try {
                const { effects } = await iotaClient.waitForTransaction({
                  digest,
                  options: { showEffects: true },
                })

                const newObjectId = effects?.created?.[0]?.reference?.objectId
                if (newObjectId) {
                  setObjectId(newObjectId)
                  if (typeof window !== "undefined") {
                    window.location.hash = newObjectId
                  }
                  console.log("‚úÖ Digital Twin minted:", newObjectId)
                } else {
                  console.warn("‚ö†Ô∏è No object ID found in transaction effects")
                }
              } catch (waitError) {
                console.error("‚ùå Error waiting for transaction:", waitError)
              } finally {
                setIsLoading(false)
              }
            },
            onError: (err) => {
              const error = err instanceof Error ? err : new Error(String(err))
              setTransactionError(error)
              console.error("‚ùå Mint error:", err)
              setIsLoading(false)
            },
          }
        )
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        setTransactionError(error)
        console.error("‚ùå Mint error:", err)
        setIsLoading(false)
      }
    },
    [signAndExecute, iotaClient]
  )

  /**
   * Add a lifecycle event to the Digital Twin
   */
  const addEvent = useCallback(
    async (eventType: number, description: string) => {
      if (!objectId) return
      if (!description.trim()) {
        setTransactionError(new Error("Description cannot be empty"))
        return
      }

      try {
        setIsLoading(true)
        setTransactionError(null)

        const tx = new Transaction()
        const descBytes = new TextEncoder().encode(description)

        tx.moveCall({
          arguments: [
            tx.object(objectId),
            tx.pure.u8(eventType),
            tx.pure.vector("u8", Array.from(descBytes)),
          ],
          target: `${PACKAGE_ID}::${CONTRACT_MODULE}::${CONTRACT_METHODS.ADD_EVENT}`,
        })

        signAndExecute(
          { transaction: tx.serialize() },
          {
            onSuccess: async ({ digest }) => {
              setHash(digest)
              await iotaClient.waitForTransaction({ digest })
              await refetch()
              console.log("‚úÖ Event added")
              setIsLoading(false)
            },
            onError: (err) => {
              const error = err instanceof Error ? err : new Error(String(err))
              setTransactionError(error)
              console.error("‚ùå Add event error:", err)
              setIsLoading(false)
            },
          }
        )
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        setTransactionError(error)
        console.error("‚ùå Add event error:", err)
        setIsLoading(false)
      }
    },
    [objectId, signAndExecute, iotaClient, refetch]
  )

  /**
   * Report the Digital Twin as lost
   */
  const reportLost = useCallback(async () => {
    if (!objectId) return

    try {
      setIsLoading(true)
      setTransactionError(null)

      const tx = new Transaction()
      tx.moveCall({
        arguments: [tx.object(objectId)],
        target: `${PACKAGE_ID}::${CONTRACT_MODULE}::${CONTRACT_METHODS.REPORT_LOST}`,
      })

      signAndExecute(
        { transaction: tx.serialize() },
        {
          onSuccess: async ({ digest }) => {
            setHash(digest)
            await iotaClient.waitForTransaction({ digest })
            await refetch()
            console.log("‚úÖ Reported lost")
            setIsLoading(false)
          },
          onError: (err) => {
            const error = err instanceof Error ? err : new Error(String(err))
            setTransactionError(error)
            console.error("‚ùå Report lost error:", err)
            setIsLoading(false)
          },
        }
      )
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setTransactionError(error)
      console.error("‚ùå Report lost error:", err)
      setIsLoading(false)
    }
  }, [objectId, signAndExecute, iotaClient, refetch])

  /**
   * Transfer ownership of the Digital Twin
   */
  const transferTwin = useCallback(
    async (recipient: string) => {
      if (!objectId) return
      if (!recipient.trim()) {
        setTransactionError(new Error("Recipient address cannot be empty"))
        return
      }

      try {
        setIsLoading(true)
        setTransactionError(null)

        const tx = new Transaction()
        tx.moveCall({
          arguments: [tx.object(objectId), tx.pure.address(recipient)],
          target: `${PACKAGE_ID}::${CONTRACT_MODULE}::${CONTRACT_METHODS.TRANSFER_TWIN}`,
        })

        signAndExecute(
          { transaction: tx.serialize() },
          {
            onSuccess: async ({ digest }) => {
              setHash(digest)
              await iotaClient.waitForTransaction({ digest })
              await refetch()
              console.log("‚úÖ Twin transferred")
              setIsLoading(false)
            },
            onError: (err) => {
              const error = err instanceof Error ? err : new Error(String(err))
              setTransactionError(error)
              console.error("‚ùå Transfer error:", err)
              setIsLoading(false)
            },
          }
        )
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        setTransactionError(error)
        console.error("‚ùå Transfer error:", err)
        setIsLoading(false)
      }
    },
    [objectId, signAndExecute, iotaClient, refetch]
  )

  /**
   * Clear current object and start fresh
   */
  const clearObject = useCallback(() => {
    setObjectId(null)
    setTransactionError(null)
    setHash(undefined)
    if (typeof window !== "undefined") {
      window.location.hash = ""
    }
  }, [])

  // ============================================================================
  // RETURN VALUES
  // ============================================================================

  const actions: ContractActions = {
    mintToSender,
    addEvent,
    reportLost,
    transferTwin,
    clearObject,
  }

  const contractState: ContractState = {
    isLoading: (isLoading && !objectId) || isPending || isFetching,
    isPending,
    isConfirming: false,
    isConfirmed: !!hash && !isLoading && !isPending,
    hash,
    error: queryError || transactionError,
  }

  return {
    data: fields,
    actions,
    state: contractState,
    objectId,
    isOwner,
    objectExists,
    hasValidData,
  }
}
```

---

# File 2: `components/sample.tsx`

```tsx
"use client"

import { useState } from "react"
import { useCurrentAccount } from "@iota/dapp-kit"
import { useContract } from "@/hooks/useContract"
import {
  Badge,
  Box,
  Button,
  Container,
  Flex,
  Heading,
  Select,
  Separator,
  Text,
  TextArea,
  TextField,
  Card,
  Strong,
  Code,
} from "@radix-ui/themes"
import ClipLoader from "react-spinners/ClipLoader"

// ============================================================================
// CONSTANTS & CONFIGURATION
// ============================================================================
type BadgeColor =
  | "gray"
  | "blue"
  | "orange"
  | "cyan"
  | "red"
  | "green"
  | "teal"
  | "yellow"
  | "amber"

const EVENT_TYPE_CONFIG: Record<number, { label: string; color: BadgeColor; icon: string }> = {
  0: { label: "Created", color: "gray", icon: "üéØ" },
  1: { label: "Maintenance (+5)", color: "blue", icon: "üîß" },
  2: { label: "Damage (-3)", color: "orange", icon: "‚ö†Ô∏è" },
  3: { label: "Inspection (+2)", color: "cyan", icon: "üîç" },
  4: { label: "Reported Lost (-50)", color: "red", icon: "üö®" },
  5: { label: "Verification (+10)", color: "green", icon: "‚úÖ" },
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

const getTrustScoreColor = (score: number): string => {
  if (score >= 75) return "var(--green-11)"
  if (score >= 40) return "var(--yellow-11)"
  return "var(--red-11)"
}

const getTrustScoreGrade = (score: number): { label: string; color: BadgeColor } => {
  if (score >= 90) return { label: "Excellent", color: "green" }
  if (score >= 75) return { label: "Good", color: "teal" }
  if (score >= 50) return { label: "Fair", color: "yellow" }
  if (score >= 25) return { label: "Poor", color: "orange" }
  return { label: "Critical", color: "red" }
}

const getAssetStatus = (data: ReturnType<typeof useContract>["data"]) => {
  if (!data) return { label: "Unknown", color: "gray" as BadgeColor }

  const lastEvent = data.logs[data.logs.length - 1]
  if (lastEvent?.event_type === 4) return { label: "Lost", color: "red" as BadgeColor }

  if (data.trust_score >= 75) return { label: "Active", color: "green" as BadgeColor }
  if (data.trust_score >= 40) return { label: "Needs Attention", color: "amber" as BadgeColor }
  return { label: "At Risk", color: "red" as BadgeColor }
}

const shortenAddress = (address: string, chars = 6): string => {
  if (address.length <= chars * 2) return address
  return `${address.slice(0, chars)}...${address.slice(-chars)}`
}

// ============================================================================
// MAIN COMPONENT
// ============================================================================

const SampleIntegration = () => {
  const currentAccount = useCurrentAccount()
  const { data, actions, state, objectId, isOwner, objectExists, hasValidData } = useContract()

  // Form states
  const [metadata, setMetadata] = useState("")
  const [eventType, setEventType] = useState("1")
  const [eventDesc, setEventDesc] = useState("")
  const [recipient, setRecipient] = useState("")
  const [showTransferConfirm, setShowTransferConfirm] = useState(false)

  const isConnected = !!currentAccount
  const status = getAssetStatus(data)
  const grade = data ? getTrustScoreGrade(data.trust_score) : null

  // ============================================================================
  // RENDER: NOT CONNECTED STATE
  // ============================================================================

  if (!isConnected) {
    return (
      <Flex
        align="center"
        justify="center"
        style={{ minHeight: "100vh", padding: "2rem", background: "var(--gray-a2)" }}
      >
        <Card style={{ maxWidth: "480px", width: "100%" }}>
          <Flex direction="column" gap="3">
            <Box>
              <Heading size="6" style={{ marginBottom: "0.5rem" }}>
                üß¨ Digital Twin Manager
              </Heading>
              <Text size="2" style={{ color: "var(--gray-a11)" }}>
                Connect your IOTA wallet to create and manage digital twins for your assets.
              </Text>
            </Box>
            <Separator size="4" />
            <Text size="2" style={{ color: "var(--gray-a11)" }}>
              <Strong>What you can do:</Strong>
              <br />
              ‚Ä¢ Mint digital twins with custom metadata
              <br />
              ‚Ä¢ Track trust scores and lifecycle events
              <br />
              ‚Ä¢ Transfer ownership securely on-chain
              <br />
              ‚Ä¢ Report lost or stolen assets
            </Text>
          </Flex>
        </Card>
      </Flex>
    )
  }

  // ============================================================================
  // RENDER: MAIN UI
  // ============================================================================

  return (
    <Box style={{ minHeight: "100vh", padding: "1.5rem", background: "var(--gray-a2)" }}>
      <Container size="4">
        {/* HEADER */}
        <Flex direction="column" gap="2" style={{ marginBottom: "2rem" }}>
          <Flex justify="between" align="start" gap="4" wrap="wrap">
            <Box>
              <Heading size="7" style={{ marginBottom: "0.5rem" }}>
                üß¨ Digital Twin Manager
              </Heading>
              <Text size="3" style={{ color: "var(--gray-a11)" }}>
                Manage asset lifecycle on IOTA blockchain
              </Text>
            </Box>
            
            {objectId && (
              <Card style={{ padding: "0.75rem 1rem" }}>
                <Text size="1" style={{ color: "var(--gray-a11)", display: "block", marginBottom: "0.25rem" }}>
                  Current Twin ID
                </Text>
                <Code size="1">{shortenAddress(objectId, 8)}</Code>
              </Card>
            )}
          </Flex>
        </Flex>

        {/* ================================================================ */}
        {/* NO DIGITAL TWIN YET - MINT NEW */}
        {/* ================================================================ */}
        {!objectId && (
          <Card size="3">
            <Flex direction="column" gap="4">
              <Box>
                <Heading size="5" style={{ marginBottom: "0.75rem" }}>
                  ü™™ Mint Your First Digital Twin
                </Heading>
                <Text size="2" style={{ color: "var(--gray-a11)" }}>
                  Create an on-chain representation of your asset. Include details like serial number,
                  model, purchase date, or any identifying information.
                </Text>
              </Box>

              <Box>
                <Text as="label" size="2" weight="bold" style={{ display: "block", marginBottom: "0.5rem" }}>
                  Asset Metadata
                </Text>
                <TextArea
                  value={metadata}
                  onChange={(e) => setMetadata(e.target.value)}
                  placeholder="Example: Dell XPS 15 Laptop - Serial: ABC123XYZ - Owner: John Doe - Purchased: 2024-01-15"
                  rows={4}
                  style={{ fontFamily: "var(--font-mono)" }}
                />
                <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                  üí° Tip: Include serial numbers, model info, and purchase details for better tracking
                </Text>
              </Box>

              <Flex gap="3" align="center" wrap="wrap">
                <Button
                  size="3"
                  onClick={() => actions.mintToSender(metadata)}
                  disabled={!metadata.trim() || state.isPending}
                >
                  {state.isPending ? (
                    <>
                      <ClipLoader size={16} color="currentColor" />
                      Minting...
                    </>
                  ) : (
                    <>üéØ Mint Digital Twin</>
                  )}
                </Button>

                <Flex direction="column" gap="1">
                  <Text size="2" style={{ color: "var(--gray-a11)" }}>
                    Initial trust score: <Strong>50/100</Strong>
                  </Text>
                  <Text size="1" style={{ color: "var(--gray-a11)" }}>
                    (Neutral starting point)
                  </Text>
                </Flex>
              </Flex>

              {state.error && (
                <Card style={{ background: "var(--red-a3)", padding: "1rem" }}>
                  <Text style={{ color: "var(--red-11)" }}>
                    <Strong>Error:</Strong> {state.error.message}
                  </Text>
                </Card>
              )}
            </Flex>
          </Card>
        )}

        {/* ================================================================ */}
        {/* HAS DIGITAL TWIN - SHOW DETAILS */}
        {/* ================================================================ */}
        {objectId && (
          <>
            {/* Loading State */}
            {state.isLoading && !data ? (
              <Flex justify="center" align="center" style={{ padding: "4rem" }}>
                <Flex direction="column" align="center" gap="3">
                  <ClipLoader size={40} />
                  <Text size="2" style={{ color: "var(--gray-a11)" }}>
                    Loading twin data...
                  </Text>
                </Flex>
              </Flex>

            ) : state.error && !objectExists ? (
              /* Error State - Object Not Found */
              <Card style={{ background: "var(--red-a3)" }}>
                <Flex direction="column" gap="3">
                  <Heading size="4">‚ö†Ô∏è Error Loading Twin</Heading>
                  <Text size="2" style={{ color: "var(--red-11)" }}>
                    {state.error.message || "Object not found or invalid"}
                  </Text>
                  <Text size="1" style={{ color: "var(--gray-a11)" }}>
                    Object ID: <Code>{objectId}</Code>
                  </Text>
                  <Button size="2" variant="soft" onClick={actions.clearObject}>
                    Clear & Mint New Twin
                  </Button>
                </Flex>
              </Card>

            ) : objectExists && !hasValidData ? (
              /* Error State - Invalid Data Structure */
              <Card style={{ background: "var(--yellow-a3)" }}>
                <Flex direction="column" gap="2">
                  <Heading size="4">üßê Invalid Data Structure</Heading>
                  <Text size="2" style={{ color: "var(--yellow-11)" }}>
                    Object exists but doesn&apos;t match expected DigitalTwin structure.
                  </Text>
                  <Button size="2" variant="soft" onClick={actions.clearObject}>
                    Clear & Mint New Twin
                  </Button>
                </Flex>
              </Card>

            ) : data ? (
              /* Main Content - Twin Details */
              <Box
                style={{
                  display: "grid",
                  gap: "1.5rem",
                  gridTemplateColumns: "repeat(auto-fit, minmax(min(100%, 400px), 1fr))",
                }}
              >
                {/* ========================================================== */}
                {/* LEFT COLUMN: TWIN INFO */}
                {/* ========================================================== */}
                <Flex direction="column" gap="4">
                  {/* Twin Overview Card */}
                  <Card size="3">
                    <Flex direction="column" gap="4">
                      <Flex justify="between" align="start" wrap="wrap" gap="2">
                        <Heading size="5">üì¶ Asset Overview</Heading>
                        <Badge size="2" color={status.color} radius="full">
                          {status.label}
                        </Badge>
                      </Flex>

                      <Separator size="4" />

                      {/* Metadata */}
                      <Box>
                        <Text size="1" weight="bold" style={{ color: "var(--gray-a11)", display: "block", marginBottom: "0.5rem" }}>
                          METADATA
                        </Text>
                        <Text size="2" style={{ fontFamily: "var(--font-mono)", wordBreak: "break-word" }}>
                          {data.metadata || "‚Äî"}
                        </Text>
                      </Box>

                      {/* Trust Score */}
                      <Box>
                        <Text size="1" weight="bold" style={{ color: "var(--gray-a11)", display: "block", marginBottom: "0.5rem" }}>
                          TRUST SCORE
                        </Text>
                        <Flex align="center" gap="3" wrap="wrap">
                          <Heading size="6" style={{ color: getTrustScoreColor(data.trust_score) }}>
                            {data.trust_score}
                            <Text size="4" style={{ color: "var(--gray-a11)" }}>/100</Text>
                          </Heading>
                          {grade && (
                            <Badge size="2" color={grade.color} variant="soft">
                              {grade.label}
                            </Badge>
                          )}
                        </Flex>
                        <Box
                          style={{
                            marginTop: "0.75rem",
                            height: "8px",
                            borderRadius: "999px",
                            background: "var(--gray-a5)",
                            overflow: "hidden",
                          }}
                        >
                          <Box
                            style={{
                              height: "100%",
                              width: `${Math.min(data.trust_score, 100)}%`,
                              background: getTrustScoreColor(data.trust_score),
                              transition: "width 0.3s ease",
                            }}
                          />
                        </Box>
                      </Box>

                      {/* Owner */}
                      <Box>
                        <Flex align="center" gap="2" style={{ marginBottom: "0.5rem" }}>
                          <Text size="1" weight="bold" style={{ color: "var(--gray-a11)" }}>
                            OWNER
                          </Text>
                          {isOwner && <Badge size="1" color="green">You</Badge>}
                        </Flex>
                        <Code size="1" style={{ wordBreak: "break-all" }}>{data.owner}</Code>
                      </Box>

                      <Separator size="2" />

                      <Text size="1" style={{ color: "var(--gray-a11)" }}>
                        Object ID: <Code>{shortenAddress(objectId, 8)}</Code>
                      </Text>
                    </Flex>
                  </Card>

                  {/* Event Logs Card */}
                  <Card size="3">
                    <Flex direction="column" gap="3">
                      <Flex justify="between" align="center">
                        <Heading size="4">üìú Event History</Heading>
                        <Badge size="1" variant="soft">
                          {data.logs.length} {data.logs.length === 1 ? "event" : "events"}
                        </Badge>
                      </Flex>

                      <Separator size="4" />

                      {data.logs.length === 0 ? (
                        <Text size="2" style={{ color: "var(--gray-a11)", textAlign: "center", padding: "2rem 0" }}>
                          No events recorded yet. Add your first event using the panel on the right.
                        </Text>
                      ) : (
                        <Flex direction="column" gap="2">
                          {[...data.logs].reverse().map((log, idx) => {
                            const config = EVENT_TYPE_CONFIG[log.event_type] || EVENT_TYPE_CONFIG[0]
                            const actualIndex = data.logs.length - idx

                            return (
                              <Box key={idx}>
                                {idx > 0 && <Separator size="2" style={{ margin: "0.5rem 0", opacity: 0.3 }} />}
                                <Flex justify="between" align="start" gap="3">
                                  <Flex direction="column" gap="1" style={{ flex: 1 }}>
                                    <Flex align="center" gap="2">
                                      <Text size="2">{config.icon}</Text>
                                      <Text size="2" weight="medium">
                                        {log.description || "(no description)"}
                                      </Text>
                                    </Flex>
                                    <Text size="1" style={{ color: "var(--gray-a11)" }}>
                                      {config.label}
                                    </Text>
                                  </Flex>
                                  <Badge size="1" variant="soft" color={config.color}>
                                    #{actualIndex}
                                  </Badge>
                                </Flex>
                              </Box>
                            )
                          })}
                        </Flex>
                      )}
                    </Flex>
                  </Card>
                </Flex>

                {/* ========================================================== */}
                {/* RIGHT COLUMN: ACTIONS */}
                {/* ========================================================== */}
                <Flex direction="column" gap="4">
                  {/* Add Event Card */}
                  <Card size="3">
                    <Flex direction="column" gap="3">
                      <Heading size="4">‚úèÔ∏è Add Lifecycle Event</Heading>
                      <Separator size="4" />

                      <Box>
                        <Text as="label" size="2" weight="bold" style={{ display: "block", marginBottom: "0.5rem" }}>
                          Event Type
                        </Text>
                        <Select.Root value={eventType} onValueChange={setEventType}>
                          <Select.Trigger />
                          <Select.Content>
                            {Object.entries(EVENT_TYPE_CONFIG)
                              .filter(([key]) => key !== "0" && key !== "4") // Exclude Created and Lost
                              .map(([value, config]) => (
                                <Select.Item key={value} value={value}>
                                  {config.icon} {config.label}
                                </Select.Item>
                              ))}
                          </Select.Content>
                        </Select.Root>
                      </Box>

                      <Box>
                        <Text as="label" size="2" weight="bold" style={{ display: "block", marginBottom: "0.5rem" }}>
                          Description
                        </Text>
                        <TextArea
                          value={eventDesc}
                          onChange={(e) => setEventDesc(e.target.value)}
                          placeholder="Describe what happened... (e.g., 'Routine maintenance completed', 'Minor scratch on back panel')"
                          rows={3}
                        />
                      </Box>

                      <Button
                        size="3"
                        onClick={() => {
                          actions.addEvent(parseInt(eventType, 10), eventDesc)
                          setEventDesc("")
                        }}
                        disabled={!eventDesc.trim() || state.isPending}
                      >
                        {state.isPending ? (
                          <>
                            <ClipLoader size={16} color="currentColor" />
                            Adding...
                          </>
                        ) : (
                          "Add Event"
                        )}
                      </Button>
                    </Flex>
                  </Card>

                  {/* Report Lost Card */}
                  <Card size="3" style={{ background: "var(--red-a2)" }}>
                    <Flex direction="column" gap="3">
                      <Heading size="4">üö® Report Asset Lost</Heading>
                      <Text size="2" style={{ color: "var(--gray-a11)" }}>
                        Mark this asset as lost or stolen. This will add a &quot;Reported lost&quot; event 
                        and severely reduce the trust score by 50 points.
                      </Text>
                      <Text size="1" style={{ color: "var(--red-11)" }}>
                        ‚ö†Ô∏è Warning: This action cannot be undone and will significantly impact the trust score.
                      </Text>
                      <Button
                        size="3"
                        color="red"
                        variant="soft"
                        onClick={actions.reportLost}
                        disabled={state.isPending}
                      >
                        {state.isPending ? (
                          <>
                            <ClipLoader size={16} color="currentColor" />
                            Reporting...
                          </>
                        ) : (
                          "Report Lost"
                        )}
                      </Button>
                    </Flex>
                  </Card>

                  {/* Transfer Twin Card (Owner Only) */}
                  {isOwner && (
                    <Card size="3">
                      <Flex direction="column" gap="3">
                        <Heading size="4">üîÑ Transfer Ownership</Heading>
                        <Text size="2" style={{ color: "var(--gray-a11)" }}>
                          Transfer this digital twin to another wallet address. The recipient will become 
                          the new owner and gain full control.
                        </Text>

                        {!showTransferConfirm ? (
                          <Button 
                            size="3" 
                            variant="soft" 
                            onClick={() => setShowTransferConfirm(true)}
                          >
                            Initiate Transfer
                          </Button>
                        ) : (
                          <>
                            <Box>
                              <Text as="label" size="2" weight="bold" style={{ display: "block", marginBottom: "0.5rem" }}>
                                Recipient Address
                              </Text>
                              <TextField.Root
                                value={recipient}
                                onChange={(e) => setRecipient(e.target.value)}
                                placeholder="0x..."
                                style={{ fontFamily: "var(--font-mono)" }}
                              />
                              <Text size="1" style={{ color: "var(--gray-a11)", marginTop: "0.5rem", display: "block" }}>
                                üí° Double-check the address - transfers cannot be reversed
                              </Text>
                            </Box>
                            <Flex gap="2">
                              <Button
                                size="3"
                                onClick={() => {
                                  actions.transferTwin(recipient)
                                  setRecipient("")
                                  setShowTransferConfirm(false)
                                }}
                                disabled={!recipient.trim() || state.isPending}
                              >
                                {state.isPending ? (
                                  <>
                                    <ClipLoader size={16} color="currentColor" />
                                    Transferring...
                                  </>
                                ) : (
                                  "Confirm Transfer"
                                )}
                              </Button>
                              <Button
                                size="3"
                                variant="soft"
                                color="gray"
                                onClick={() => {
                                  setShowTransferConfirm(false)
                                  setRecipient("")
                                }}
                                disabled={state.isPending}
                              >
                                Cancel
                              </Button>
                            </Flex>
                          </>
                        )}
                      </Flex>
                    </Card>
                  )}

                  {/* Transaction Status Card */}
                  {(state.hash || state.error) && (
                    <Card 
                      size="2" 
                      style={{ 
                        background: state.error ? "var(--red-a3)" : "var(--gray-a3)",
                        border: state.error ? "1px solid var(--red-a6)" : "1px solid var(--gray-a6)"
                      }}
                    >
                      <Flex direction="column" gap="2">
                        {state.hash && (
                          <Box>
                            <Text size="1" weight="bold" style={{ color: "var(--gray-a11)", display: "block", marginBottom: "0.5rem" }}>
                              Transaction Hash
                            </Text>
                            <Code size="1" style={{ wordBreak: "break-all" }}>
                              {shortenAddress(state.hash, 10)}
                            </Code>
                            {state.isConfirmed && (
                              <Flex align="center" gap="2" style={{ marginTop: "0.75rem" }}>
                                <Text size="2" style={{ color: "var(--green-11)" }}>
                                  ‚úÖ Transaction confirmed
                                </Text>
                              </Flex>
                            )}
                          </Box>
                        )}

                        {state.error && (
                          <Box 
                            style={{
                              marginTop: state.hash ? "0.75rem" : 0,
                              padding: "0.75rem",
                              borderRadius: "8px",
                              background: "var(--red-a4)",
                            }}
                          >
                            <Text size="2" style={{ color: "var(--red-11)" }}>
                              <Strong>Error:</Strong> {state.error.message}
                            </Text>
                          </Box>
                        )}
                      </Flex>
                    </Card>
                  )}
                </Flex>
              </Box>
            ) : null}
          </>
        )}
      </Container>
    </Box>
  )
}

export default SampleIntegration
```

---

# Your Task

Return **two updated files**:

## 1. `hooks/useContract.ts`

- Keep all TypeScript interfaces
- Preserve loading, error, and transaction state logic
- Maintain hook object structure
- Keep contract calls functional
- Use Package ID: `0x703c97fb88edc981081307351be009b7815b1f5ae2e31421e9ef9d84bf2b0856` and Module: `contract`
- Only implement requested changes

## 2. `components/sample.tsx`

- Keep UI behavior and wallet checks
- Preserve loading, error, object state and transaction UI
- Maintain interaction logic unless specified
- Apply only requested modifications
